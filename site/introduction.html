<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>介绍 &middot; 合成解释器</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="contents">
<h3><a href="#top">介绍<small>1</small></a></h3>

<ul>
    <li><a href="#why-learn-this-stuff"><small>1.1</small> 为什么要学它？</a></li>
    <li><a href="#how-the-book-is-organized"><small>1.2</small> 这本书是如何组织的</a></li>
    <li><a href="#the-first-interpreter"><small>1.3</small> 第一个解释器</a></li>
    <li><a href="#the-second-interpreter"><small>1.4</small> 第二个解释器</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">挑战</a></li>
    <li class="end-part"><a href="#design-note"><small>note</small>名字有什么意义？</a></li>
</ul>


<div class="prev-next">
    <a href="welcome.html" title="Welcome" class="left">&larr;&nbsp;上一页</a>
    <a href="welcome.html" title="Welcome">&uarr;&nbsp;上一级</a>
    <a href="a-map-of-the-territory.html" title="A Map of the Territory" class="right">下一页&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
<a href="welcome.html" title="Welcome" class="prev">←</a>
<a href="a-map-of-the-territory.html" title="A Map of the Territory" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<h3><a href="#top">介绍<small>1</small></a></h3>

<ul>
    <li><a href="#why-learn-this-stuff"><small>1.1</small> 为什么要学它？</a></li>
    <li><a href="#how-the-book-is-organized"><small>1.2</small> 这本书是如何组织的</a></li>
    <li><a href="#the-first-interpreter"><small>1.3</small> 第一个解释器</a></li>
    <li><a href="#the-second-interpreter"><small>1.4</small> 第二个解释器</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">挑战</a></li>
    <li class="end-part"><a href="#design-note"><small>note</small>名字有什么意义？</a></li>
</ul>


<div class="prev-next">
    <a href="welcome.html" title="Welcome" class="left">&larr;&nbsp;上一页</a>
    <a href="welcome.html" title="Welcome">&uarr;&nbsp;上一级</a>
    <a href="a-map-of-the-territory.html" title="A Map of the Territory" class="right">下一页&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">1</div>
  <h1>介绍</h1>

<blockquote>
<p>童话故事并不现实：不是因为它告诉我们恶龙是存在的，而是因为它告诉我们恶龙是可以被打败的。</p>
<p><cite>G.K. Chesterton在Neil Gaiman, <em>Coraline</em>中所写。</cite></p>
</blockquote>
<p>我对我们能一起踏上这趟旅程非常兴奋。这是一本为编程语言实现解释器的书籍，但它同时也是一本教我们设计出值得实现的语言的书籍。这是一本我希望我在初次踏入编程语言领域时就能拥有的书籍，并且这本书也已经在我的<span name="head">脑中</span>写了近十年。
<aside name="head">
<p>我这几年一直在想这个事，对朋友和家人我非常抱歉！</p>
</aside>
<p>在这本书中，我们将一步一步实现两个为一个拥有完整特性编程语言实现的完整的解释器。我认为这很可能是你们对编程语言领域的第一次进军，因此我将会讲到几乎每一个概念、写到几乎每一行你需要搭建出一个完整的、可用的、快速的编程语言实现。</p>
<p>为了能让我完整地在这本书中实现我们的两个解释器而且不让你们看了这本书之后放弃进军编程语言领域的想法，在理论方面我们的讲解要比其他的类似书籍少。由于我们要构建这个完备解释器的所有部分，我将会介绍这后面的历史和概念。我会尽量让你们了解这一领域的行话，这样如果你找到一个满是编程语言研究者的<span name="party">聚会</span>，你能和里面的人聊天。</p>
<aside name="party">
<p>尽管很奇怪，但我经常置身于这种状况。你甚至根本不知道里面的人多会喝酒（知道了你也不会信）。</p>
</aside>
<p>但我们需要大量消耗脑细胞的地方是让这个语言能够顺利地构建并运行，而这并不代表理论不重要。能够把其中的语法和语义精确、<span name="formal">正式</span>地讲解出来是一种你创建编程语言时会经常用到的技能。但是个人认为，动手操作才是最好的学习方法。对我来说，把一大串满是抽象概念的词句记下来并真正消化是很困难的。但如果我写出了一点东西，运行它，然后调试它，我更能<em>理解</em>整个过程。</p>
<aside name="formal">
<p>强类型语言通常很需要严格、正式的类型体系。自己创建一个或者理解别人的类型系统几乎和看懂一个数学定理的证明的难度相当。</p>
<p>这并不是巧合。在20世纪中叶，哈斯卡尔·柯里和威廉·阿尔文·霍华德说明了它们不过是一个硬币的两面，这就是<a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">柯里-霍华德同构</a>。</p>
</aside>
<p>而那正是我想让你达成的目标。我想让你在这个过程中能够对一个真实的语言是如何运转的有一种固化在脑子里的直觉。我希望你再读其他的更加理论化的书时，这本书中提到的这些理论能牢牢记在你心中。</p>
<h2><a href="#why-learn-this-stuff" id="why-learn-this-stuff"><small>1&#8202;.&#8202;1</small>为什么要学它？</a></h2>
<p>几乎每一本编程语言书的介绍都会有这一小节。我不知道为什么这几乎是在编程语言领域里普遍存在的一个疑问。我不认为那些研究鸟类的书籍会想到去辩护这一学问的存在。它们只是假设读者非常喜欢鸟类，然后就开始下面的讲述了。</p>
<p>但是编程语言这一领域与鸟类学有一点小小的不同，我认为我们中的一个能够创建一个非常成功且通用的编程语言的概率很小。那些世界上不少人都在用的编程语言的设计者可能很适应大众车型的房车，即使不把上面的棚子拉开也没事。如果加入那种圈子是学习创建编程语言的<em>唯一</em>理由，那么你们肯定很难接受。幸运的是，这并不是唯一的原因。</p>
<h3><a href="#little-languages-are-everywhere" id="little-languages-are-everywhere"><small>1&#8202;.&#8202;1&#8202;.&#8202;1</small>小型语言到处都是</a></h3>
<p>对于每一种成功的通用编程语言，都会对应上一打专注于一小部分领域的语言。曾经我们叫它们&ldquo;小型语言&rdquo;，但是随着我们越来越爱用更加云山雾罩的术语，现在它们叫&ldquo;领域特定语言&rdquo;。它们天生就是用来完成特定任务的，比如帮助我们构建应用程序的脚本语言、模板引擎、标记语言或者配置文件。</p>
<p><span name="little"></span><img src="image/introduction/little-languages.png" alt="A random selection of little languages." /></p>
<aside name="little">
<p>随便选了一些你可能会遇到的小型语言。</p>
</aside>
<p>基本上每一个大项目都会需要这些类似的东西。如果你可以找到符合你应用场景的语言，尽量去用它而非自己造一个。一旦你开始为文档、调试器、编辑器支持、语法高亮等其他各种陷阱而抓狂时，自己做一个小型语言去完成这些事也许是最佳选择。</p>
<p>但是事实上我们仍然会需要用一些工具生成解析器但是虽然有这类工具却一个都不适合的这种情况。就算你在使用他人造好的轮子，你也仍然会不可避免地需要去调试和试探它能做到什么地步。</p>
<h3><a href="#languages-are-great-exercise" id="languages-are-great-exercise"><small>1&#8202;.&#8202;1&#8202;.&#8202;2</small>做语言是对代码水平的一个练习</a></h3>
<p>长跑运动员有时会在脚踝上绑上重物或在高海拔地区训练。这样一旦他们来到正常的（身体更加轻巧、氧气更加充足）的地带就可以跑得更远、更快。</p>
<p>实现一门编程语言是一场对编程语言技能的真实考验。代码很有可能不仅非常复杂，而且运行表现也会很差。你必须要对递归、动态数组、树、图还有哈希表非常掌握才行。你很有可能每天都在用哈希表，但是你<em>真的</em>理解它吗？等我们从零开始自己做出一个之后，我保证你会理解它。</p>
<p>当我在给你展示了写出一个解释器并没有那么难之后，实现一个仍然是一种挑战。如果你真的成功了，你将会成为一个更强的程序员，同时你每天使用的数据结构和算法都会被安排得更加妥当。</p>
<h3><a href="#one-more-reason" id="one-more-reason"><small>1&#8202;.&#8202;1&#8202;.&#8202;3</small>还有一个原因</a></h3>
<p>最后一个原因对我来说难以承认，因为它基本上是我个人的原因。从我在孩提时代学习如何编程时，我就感觉编程语言非常神奇。当我打出我人生中第一个BASIC程序时，我甚至根本不知道BASIC<em>本身</em>是怎么做出来的。</p>
<p>后来，我那些大学里的朋友谈论到自己编程语言课程时的那种敬畏和恐惧更让我认为这些创造编程语言的人像是另一种人类<span class="em">&mdash;</span>某种能够有特权去进行神秘艺术的巫师。</p>
<p>这是一个非常迷人的<span name="image">图像</span>，但它还有另一面。<em>我</em>并不像一个巫师，因此我后来认为我可能天生缺少某种特殊的品质，而这种品质正是我加入这一行列所必要的。尽管从我大学在笔记本上写上关键词词时已经被编程语言迷住了，我还是花了几十年的时间去鼓起勇气真正去学习它们。那种&ldquo;神奇&rdquo;的品质，那种强烈的排斥性，把<em>我</em>挡在了门外。</p>
<aside name="image">
<p>这个领域的写作者们对要放这类图片并没有犹豫。两本非常有名的编程语言领域教科书就在封面上用了<a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">龙</a>和<a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html">巫师</a>。</p>
</aside>
<p>当我最终开始拼凑我的小型解释器时，我很快就知道，&ldquo;当然，这里没有魔法&rdquo;。不过是一堆代码，而那些创建了编程语言的人也不过是普通人。</p>
<p>确实<em>有</em>一些技术你并不会经常在编程语言领域之外用到，而有一些部分会有点难。但是这个领域中，基本上没有能够阻挡你克服这些困难的困难。我希望如果你曾经被这一领域的各种方面里的各种原因而被吓倒，这本书能够帮你克服这份恐惧，但也许我只会给你一丁点比之前多的勇气呢。 </p>
<p>而且，也许有一天你<em>会</em>成为下一个伟大语言的作者。毕竟总得有个人成为这种身份的人吧。</p>
<h2><a href="#how-the-book-is-organized" id="how-the-book-is-organized"><small>1&#8202;.&#8202;2</small>这本书是如何组织的</a></h2>
<p>这本书分为三个部分，而你正在读的就是第一部分。这一部分由多个章节组成，它会教会你那些编程语言创造者的常用术语，并且介绍 Lox 语言，也就是我们后面要实现的语言。</p>
<p>剩下的两个部分每一个部分都会实现一个完整的 Lox 解释器。这两个部分的章节基本上都是同一种结构。这些章节讲唯一的一个语言特性，教给你它后面隐藏的概念，并且带你走过一个语言的完整实现。</p>
<p>整个过程的实验和其中出现的错误给我带来了深刻的印象，但我还是成功地把整本书地两个解释器的各种实现过程转变为了很多可以单独作为一章的块，它们基于前面所有章节的知识，但不需要后续章节的内容。在这两个部分的第一个章节中，你就会得到一个可以运行的程序，你可以在其中随便玩耍。当一个又一个章节过去，它会慢慢生长并拥有更多特性，直到最后你完成这个语言。</p>
<p>除去那些书中丰富的英文句子意外，每个章节还有其他的一些东西：</p>
<h3><a href="#the-code" id="the-code"><small>1&#8202;.&#8202;2&#8202;.&#8202;1</small>代码</a></h3>
<p>我们将要<em>合成g</em>解释器，所以这本书里会有真实的代码。Every single line of code needed is included, and each snippet tells you where to insert it in your ever-growing implementation.</p>
<p>Many other language books and language implementations use tools like <a href="https://en.wikipedia.org/wiki/Lex_(software)">Lex</a>
and <span name="yacc"><a href="https://en.wikipedia.org/wiki/Yacc">Yacc</a></span>, so-called <strong>compiler-compilers</strong>, that
automatically generate some of the source files for an implementation from some
higher-level description. There are pros and cons to tools like those, and
strong opinions<span class="em">&mdash;</span>some might say religious convictions<span class="em">&mdash;</span>on both sides.</p>
<aside name="yacc">
<p>Yacc is a tool that takes in a grammar file and produces a source file for a
compiler, so it&rsquo;s sort of like a &ldquo;compiler&rdquo; that outputs a compiler, which is
where we get the term &ldquo;compiler-compiler&rdquo;.</p>
<p>Yacc wasn&rsquo;t the first of its ilk, which is why it&rsquo;s named &ldquo;Yacc&rdquo;<span class="em">&mdash;</span><em>Yet
Another</em> Compiler-Compiler. A later similar tool is <a href="https://en.wikipedia.org/wiki/GNU_bison">Bison</a>, named as a pun on
the pronunciation of Yacc like &ldquo;yak&rdquo;.</p><img src="image/introduction/yak.png" alt="A yak." />
<p>If you find all of these little self-references and puns charming and fun,
you&rsquo;ll fit right in here. If not, well, maybe the language nerd sense of humor
is an acquired taste.</p>
</aside>
<p>We will abstain from using them here. I want to ensure there are no dark corners
where magic and confusion can hide, so we&rsquo;ll write everything by hand. As you&rsquo;ll
see, it&rsquo;s not as bad as it sounds, and it means you really will understand each
line of code and how both interpreters work.</p>
<p>A book has different constraints from the &ldquo;real world&rdquo; and so the coding style
here might not always reflect the best way to write maintainable production
software. If I seem a little cavalier about, say, omitting <code>private</code> or
declaring a global variable, understand I do so to keep the code easier on your
eyes. The pages here aren&rsquo;t as wide as your IDE and every character counts.</p>
<p>Also, the code doesn&rsquo;t have many comments. That&rsquo;s because each handful of lines
is surrounded by several paragraphs of honest-to-God prose explaining it. When
you write a book to accompany your program, you are welcome to omit comments
too. Otherwise, you should probably use <code>//</code> a little more than I do.</p>
<p>While the book contains every line of code and teaches what each means, it does
not describe the machinery needed to compile and run the interpreter. I assume
you can slap together a makefile or a project in your IDE of choice in order to
get the code to run. Those kinds of instructions get out of date quickly, and
I want this book to age like XO brandy, not backyard hooch.</p>
<h3><a href="#snippets" id="snippets"><small>1&#8202;.&#8202;2&#8202;.&#8202;2</small>Snippets</a></h3>
<p>Since the book contains literally every line of code needed for the
implementations, the snippets are quite precise. Also, because I try to keep the
program in a runnable state even when major features are missing, sometimes we
add temporary code that gets replaced in later snippets.</p>
<p>A snippet with all the bells and whistles looks like this:</p>
<div class="codehilite"><pre class="insert-before">
      default:
</pre><div class="source-file"><em>lox/Scanner.java</em><br>
in <em>scanToken</em>()<br>
replace 1 line</div>
<pre class="insert">
        <span class="k">if</span> (<span class="i">isDigit</span>(<span class="i">c</span>)) {
          <span class="i">number</span>();
        } <span class="k">else</span> {
          <span class="t">Lox</span>.<span class="i">error</span>(<span class="i">line</span>, <span class="s">&quot;Unexpected character.&quot;</span>);
        }
</pre><pre class="insert-after">
        break;
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, in <em>scanToken</em>(), replace 1 line</div>
<p>In the center, you have the new code to add. It may have a few faded out lines
above or below to show where it goes in the existing surrounding code. There is
also a little blurb telling you in which file and where to place the snippet. If
that blurb says &ldquo;replace _ lines&rdquo;, there is some existing code between the faded
lines that you need to remove and replace with the new snippet.</p>
<h3><a href="#asides" id="asides"><small>1&#8202;.&#8202;2&#8202;.&#8202;3</small>Asides</a></h3>
<p><span name="joke">Asides</span> contain biographical sketches, historical
background, references to related topics, and suggestions of other areas to
explore. There&rsquo;s nothing that you <em>need</em> to know in them to understand later
parts of the book, so you can skip them if you want. I won&rsquo;t judge you, but I
might be a little sad.</p>
<aside name="joke">
<p>Well, some asides do, at least. Most of them are just dumb jokes and amateurish
drawings.</p>
</aside>
<h3><a href="#challenges_" id="challenges_"><small>1&#8202;.&#8202;2&#8202;.&#8202;4</small>Challenges</a></h3>
<p>Each chapter ends with a few exercises. Unlike textbook problem sets, which tend
to review material you already covered, these are to help you learn <em>more</em> than
what&rsquo;s in the chapter. They force you to step off the guided path and explore on
your own. They will make you research other languages, figure out how to
implement features, or otherwise get you out of your comfort zone.</p>
<p><span name="warning">Vanquish</span> the challenges and you&rsquo;ll come away with a
broader understanding and possibly a few bumps and scrapes. Or skip them if you
want to stay inside the comfy confines of the tour bus. It&rsquo;s your book.</p>
<aside name="warning">
<p>A word of warning: the challenges often ask you to make changes to the
interpreter you&rsquo;re building. You&rsquo;ll want to implement those in a copy of your
code. The later chapters assume your interpreter is in a pristine
(&ldquo;unchallenged&rdquo;?) state.</p>
</aside>
<h3><a href="#design-notes" id="design-notes"><small>1&#8202;.&#8202;2&#8202;.&#8202;5</small>Design notes</a></h3>
<p>Most &ldquo;programming language&rdquo; books are strictly programming language
<em>implementation</em> books. They rarely discuss how one might happen to <em>design</em> the
language being implemented. Implementation is fun because it is so <span
name="benchmark">precisely defined</span>. We programmers seem to have an
affinity for things that are black and white, ones and zeroes.</p>
<aside name="benchmark">
<p>I know a lot of language hackers whose careers are based on this. You slide a
language spec under their door, wait a few months, and code and benchmark
results come out.</p>
</aside>
<p>Personally, I think the world needs only so many implementations of <span
name="fortran">FORTRAN 77</span>. At some point, you find yourself designing a
<em>new</em> language. Once you start playing <em>that</em> game, then the softer, human side
of the equation becomes paramount. Things like which features are easy to learn,
how to balance innovation and familiarity, what syntax is more readable and to
whom.</p>
<aside name="fortran">
<p>Hopefully your new language doesn&rsquo;t hardcode assumptions about the width of a
punched card into its grammar.</p>
</aside>
<p>All of that stuff profoundly affects the success of your new language. I want
your language to succeed, so in some chapters I end with a &ldquo;design note&rdquo;, a
little essay on some corner of the human aspect of programming languages. I&rsquo;m no
expert on this<span class="em">&mdash;</span>I don&rsquo;t know if anyone really is<span class="em">&mdash;</span>so take these with a large
pinch of salt. That should make them tastier food for thought, which is my main
aim.</p>
<h2><a href="#the-first-interpreter" id="the-first-interpreter"><small>1&#8202;.&#8202;3</small>第一个解释器</a></h2>
<p>We&rsquo;ll write our first interpreter, jlox, in <span name="lang">Java</span>. The
focus is on <em>concepts</em>. We&rsquo;ll write the simplest, cleanest code we can to
correctly implement the semantics of the language. This will get us comfortable
with the basic techniques and also hone our understanding of exactly how the
language is supposed to behave.</p>
<aside name="lang">
<p>The book uses Java and C, but readers have ported the code to <a href="https://github.com/munificent/craftinginterpreters/wiki/Lox-implementations">many other
languages</a>. If the languages I picked aren&rsquo;t your bag, take a look at
those.</p>
</aside>
<p>Java is a great language for this. It&rsquo;s high level enough that we don&rsquo;t get
overwhelmed by fiddly implementation details, but it&rsquo;s still pretty explicit.
Unlike in scripting languages, there tends to be less complex machinery hiding
under the hood, and you&rsquo;ve got static types to see what data structures you&rsquo;re
working with.</p>
<p>I also chose Java specifically because it is an object-oriented language. That
paradigm swept the programming world in the &rsquo;90s and is now the dominant way of
thinking for millions of programmers. Odds are good you&rsquo;re already used to
organizing code into classes and methods, so we&rsquo;ll keep you in that comfort
zone.</p>
<p>While academic language folks sometimes look down on object-oriented languages,
the reality is that they are widely used even for language work. GCC and LLVM
are written in C++, as are most JavaScript virtual machines. Object-oriented
languages are ubiquitous, and the tools and compilers <em>for</em> a language are often
written <em>in</em> the <span name="host">same language</span>.</p>
<aside name="host">
<p>A compiler reads files in one language, translates them, and outputs files in
another language. You can implement a compiler in any language, including the
same language it compiles, a process called <strong>self-hosting</strong>.</p>
<p>You can&rsquo;t compile your compiler using itself yet, but if you have another
compiler for your language written in some other language, you use <em>that</em> one to
compile your compiler once. Now you can use the compiled version of your own
compiler to compile future versions of itself, and you can discard the original
one compiled from the other compiler. This is called <strong>bootstrapping</strong>, from
the image of pulling yourself up by your own bootstraps.</p><img src="image/introduction/bootstrap.png" alt="Fact: This is the primary mode of transportation of the American cowboy." />
</aside>
<p>And, finally, Java is hugely popular. That means there&rsquo;s a good chance you
already know it, so there&rsquo;s less for you to learn to get going in the book. If
you aren&rsquo;t that familiar with Java, don&rsquo;t freak out. I try to stick to a fairly
minimal subset of it. I use the diamond operator from Java 7 to make things a
little more terse, but that&rsquo;s about it as far as &ldquo;advanced&rdquo; features go. If you
know another object-oriented language, like C# or C++, you can muddle through.</p>
<p>By the end of part II, we&rsquo;ll have a simple, readable implementation. It&rsquo;s not
very fast, but it&rsquo;s correct. However, we are only able to accomplish that by
building on the Java virtual machine&rsquo;s own runtime facilities. We want to learn
how Java <em>itself</em> implements those things.</p>
<h2><a href="#the-second-interpreter" id="the-second-interpreter"><small>1&#8202;.&#8202;4</small>第二个解释器</a></h2>
<p>So in the next part, we start all over again, but this time in C. C is the
perfect language for understanding how an implementation <em>really</em> works, all the
way down to the bytes in memory and the code flowing through the CPU.</p>
<p>A big reason that we&rsquo;re using C is so I can show you things C is particularly
good at, but that <em>does</em> mean you&rsquo;ll need to be pretty comfortable with it. You
don&rsquo;t have to be the reincarnation of Dennis Ritchie, but you shouldn&rsquo;t be
spooked by pointers either.</p>
<p>If you aren&rsquo;t there yet, pick up an introductory book on C and chew through it,
then come back here when you&rsquo;re done. In return, you&rsquo;ll come away from this book
an even stronger C programmer. That&rsquo;s useful given how many language
implementations are written in C: Lua, CPython, and Ruby&rsquo;s MRI, to name a few.</p>
<p>In our C interpreter, <span name="clox">clox</span>, we are forced to implement
for ourselves all the things Java gave us for free. We&rsquo;ll write our own dynamic
array and hash table. We&rsquo;ll decide how objects are represented in memory, and
build a garbage collector to reclaim them.</p>
<aside name="clox">
<p>I pronounce the name like &ldquo;sea-locks&rdquo;, but you can say it &ldquo;clocks&rdquo; or even
&ldquo;cloch&rdquo;, where you pronounce the &ldquo;x&rdquo; like the Greeks do if it makes you happy.</p>
</aside>
<p>Our Java implementation was focused on being correct. Now that we have that
down, we&rsquo;ll turn to also being <em>fast</em>. Our C interpreter will contain a <span
name="compiler">compiler</span> that translates Lox to an efficient bytecode
representation (don&rsquo;t worry, I&rsquo;ll get into what that means soon), which it then
executes. This is the same technique used by implementations of Lua, Python,
Ruby, PHP, and many other successful languages.</p>
<aside name="compiler">
<p>你以为这只是一本教你做解释器的书吗？它其实也时一本教你做编译器的书，一本书的钱相当于买了两本书！</p>
</aside>
<p>We&rsquo;ll even try our hand at benchmarking and optimization. By the end, we&rsquo;ll have
a robust, accurate, fast interpreter for our language, able to keep up with
other professional caliber implementations out there. Not bad for one book and a
few thousand lines of code.</p>
<div class="challenges">
<h2><a href="#challenges" id="challenges">挑战</a></h2>
<ol>
<li>
<p>There are at least six domain-specific languages used in the <a href="https://github.com/munificent/craftinginterpreters">little system
I cobbled together</a> to write and publish this book. What are they?</p>
</li>
<li>
<p>Get a &ldquo;Hello, world!&rdquo; program written and running in Java. Set up whatever
makefiles or IDE projects you need to get it working. If you have a
debugger, get comfortable with it and step through your program as it runs.</p>
</li>
<li>
<p>Do the same thing for C. To get some practice with pointers, define a
<a href="https://en.wikipedia.org/wiki/Doubly_linked_list">doubly linked list</a> of heap-allocated strings. Write functions to insert,
find, and delete items from it. Test them.</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#design-note" id="design-note">设计说明：名字有什么意义？</a></h2>
<p>在写作这本书时最难的挑战之一就是给我们即将实现的语言取名。我在正式定名之前选了有<em>几页</em>厚的候选名称。就像你将会发现的那样，当你磨刀霍霍准备开始实现时，取名是一件看似简单但实则非常困难的事。一个好名字需要满足以下准则：</p>
<ol>
<li>
<p><strong> 它之前没有被使用过。</strong> 如果你用了其他人取的名字，你将会遇到各种社会和法律上的麻烦。</p>
</li>
<li>
<p><strong> 它需要易于发音和拼写。</strong> 如果进展顺利，将会有不少人说和写你语言的名字。一旦字母和音节变多，他们将会因此陷入无休止的烦恼。</p>
</li>
<li>
<p><strong> 它需要非常独特并且能够被搜到。</strong> People will Google your language&rsquo;s
name to learn about it, so you want a word that&rsquo;s rare enough that most
results point to your docs. Though, with the amount of AI search engines are
packing today, that&rsquo;s less of an issue. Still, you won&rsquo;t be doing your users
any favors if you name your language &ldquo;for&rdquo;.</p>
</li>
<li>
<p><strong>It doesn&rsquo;t have negative connotations across a number of cultures.</strong> This
is hard to be on guard for, but it&rsquo;s worth considering. The designer of
Nimrod ended up renaming his language to &ldquo;Nim&rdquo; because too many people
remember that Bugs Bunny used &ldquo;Nimrod&rdquo; as an insult. (Bugs was using it
ironically.)</p>
</li>
</ol>
<p>If your potential name makes it through that gauntlet, keep it. Don&rsquo;t get hung
up on trying to find an appellation that captures the quintessence of your
language. If the names of the world&rsquo;s other successful languages teach us
anything, it&rsquo;s that the name doesn&rsquo;t matter much. All you need is a reasonably
unique token.</p>
</div>

<footer>
<a href="a-map-of-the-territory.html" class="next">
  下一章：&ldquo;一张地图&rdquo; &rarr;
</a>
由 Robert Nystrom 手写&ensp;&mdash;&ensp;<a href="https://hub.fastgit.xyz/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2021</a>
</footer>
</article>

</div>
</body>
</html>
